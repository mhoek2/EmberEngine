#version 430
#extension GL_ARB_shading_language_include : require

#include "common_structs.glsl"

layout( std430, binding = 3 )	buffer BatchBuffer					{ BatchBlock batches[];				};
layout( std430, binding = 4 )	buffer ModelBuffer					{ ModelBlock models[];				};
layout( std430, binding = 5 )	buffer GameObjectMatrices			{ GameObjectBlock gameObjects[];	};
layout( std430, binding = 6 )	buffer GpuCounter					{ uint num_gameObjects;				};
layout( std430, binding = 7 )	buffer MeshInstanceCounterBuffer	{ uint meshInstanceCounter[];		};
layout( std430, binding = 8 )	buffer ObjectCounter				{ uint num_objects;				};
layout( std430, binding = 9 )	buffer InstancesBuffer				{ InstancesBlock instances[];		};
layout( std430, binding = 12)	buffer MeshNodeToBatchBuffer		{ int  meshNodeToBatch[];			};
layout( std430, binding = 10)   buffer visBuffer                    { uint visbuf[];		            };

layout(local_size_x = 64) in;

// plane frustum culling
#define MAX_NODES_PER_MODEL 100
bool isVisible( in uint gid, in uint n )
{
	// use one uint per node (max: MAX_NODES_PER_MODEL)
    //uint nodeIndex = gid * MAX_NODES_PER_MODEL + n;
	//if (visbuf[nodeIndex] == 1u) 
	//	return true;

	// use one bit per node (max: MAX_NODES_PER_MODEL * 32)
    uint visIndex = gid * MAX_NODES_PER_MODEL + (n >> 5);
    uint bitIndex = n & 31u;

	if ((visbuf[visIndex] & (1u << bitIndex)) == 1u)
		return true;

	return false;
}


void main()
{	
	uint gid = gl_GlobalInvocationID.x;

	if (gid >= num_gameObjects) return;

	GameObjectBlock obj = gameObjects[gid];
	ModelBlock model = models[obj.model_index];

	if (obj.enabled == 0) return;

	for (uint n = 0; n < model.nodeCount; n++) {
		uint meshNodeMatrixId = model.nodeOffset + n;

		uint object_idx = atomicAdd(num_objects, 1);

		// retrieve the actual index in the compacted batch buffer
		int batchIndex = meshNodeToBatch[meshNodeMatrixId];

		// -1 means its unused/no instances for this model
		if (batchIndex < 0) continue; 

		// use uint per node
        //uint nodeIndex = gid * MAX_NODES_PER_MODEL + n;
		//if (visbuf[nodeIndex] == 0u) continue;

		// use one bit per node
        uint visIndex = gid * MAX_NODES_PER_MODEL + (n >> 5);
        uint bitIndex = n & 31u;
		if ((visbuf[visIndex] & (1u << bitIndex)) == 0u) continue;

		// get current instance count for this mesh/node then increment by one
		uint local = atomicAdd(meshInstanceCounter[meshNodeMatrixId], 1);

		// compute destination index in the instance buffer
		uint dst   = uint(batches[batchIndex].baseInstance) + local;

		// bind gameObject and store index of mesh/node for later lookup
		instances[ dst ].ObjectId = object_idx;
	}
}