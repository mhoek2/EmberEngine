#version 430
#extension GL_ARB_shading_language_include : require

#include "common_structs.glsl"

uniform mat4 uVMatrix;
uniform mat4 uPMatrix;

layout( std430, binding = 1 )	buffer MeshNodeBuffer	            { MeshNodeBlock mesh_node[];        };
layout( std430, binding = 4 )	buffer ModelBuffer					{ ModelBlock models[];				};
layout( std430, binding = 5 )	buffer GameObjectMatrices			{ GameObjectBlock gameObjects[];	};
layout( binding = 6)			buffer GpuCounter					{ uint numGameObjects;				};
layout( binding = 7)			buffer MeshInstanceCounterBuffer	{ uint meshInstanceCounter[];		};
layout( std430, binding = 10)   buffer visBuffer                    { uint visbuf[];		            };

layout(local_size_x = 64) in;

// plane frustum culling
#define MAX_NODES_PER_MODEL 100
struct Plane {
    vec3 n;
    float d;
};
shared Plane planes[6];

void frustumPlanes( in mat4 m )
{
	planes[0] = Plane(vec3(m[0][3] + m[0][0], m[1][3] + m[1][0], m[2][3] + m[2][0]), m[3][3] + m[3][0]); // left
	planes[1] = Plane(vec3(m[0][3] - m[0][0], m[1][3] - m[1][0], m[2][3] - m[2][0]), m[3][3] - m[3][0]); // right
	planes[2] = Plane(vec3(m[0][3] + m[0][1], m[1][3] + m[1][1], m[2][3] + m[2][1]), m[3][3] + m[3][1]); // bottom
	planes[3] = Plane(vec3(m[0][3] - m[0][1], m[1][3] - m[1][1], m[2][3] - m[2][1]), m[3][3] - m[3][1]); // top
	planes[4] = Plane(vec3(m[0][3] + m[0][2], m[1][3] + m[1][2], m[2][3] + m[2][2]), m[3][3] + m[3][2]); // near
	planes[5] = Plane(vec3(m[0][3] - m[0][2], m[1][3] - m[1][2], m[2][3] - m[2][2]), m[3][3] - m[3][2]); // far
}

bool frustumAABB( in vec3 mn, in vec3 mx, in Plane p )
{
    vec3 v = vec3(
        p.n.x > 0.0 ? mx.x : mn.x,
        p.n.y > 0.0 ? mx.y : mn.y,
        p.n.z > 0.0 ? mx.z : mn.z
    );
    return dot(p.n, v) + p.d >= 0.0;
}

bool frustumCull( in GameObjectBlock obj, in uint meshNodeMatrixId )
{
    MeshNodeBlock node = mesh_node[meshNodeMatrixId];
    mat4 world = obj.model * node.model;

    vec3 corners[8];
    corners[0] = vec3(node.min_aabb.x, node.min_aabb.y, node.min_aabb.z);
    corners[1] = vec3(node.min_aabb.x, node.min_aabb.y, node.max_aabb.z);
    corners[2] = vec3(node.min_aabb.x, node.max_aabb.y, node.min_aabb.z);
    corners[3] = vec3(node.min_aabb.x, node.max_aabb.y, node.max_aabb.z);
    corners[4] = vec3(node.max_aabb.x, node.min_aabb.y, node.min_aabb.z);
    corners[5] = vec3(node.max_aabb.x, node.min_aabb.y, node.max_aabb.z);
    corners[6] = vec3(node.max_aabb.x, node.max_aabb.y, node.min_aabb.z);
    corners[7] = vec3(node.max_aabb.x, node.max_aabb.y, node.max_aabb.z);
        
    vec3 worldMin = vec3(1e20);
    vec3 worldMax = vec3(-1e20);
        
    for (int i = 0; i < 8; i++) {
        vec4 wc = world * vec4(corners[i], 1.0);
        worldMin = min(worldMin, wc.xyz);
        worldMax = max(worldMax, wc.xyz);
    }
        
    bool visible = true;
    for (int i = 0; i < 6; i++) {
        if (!frustumAABB(worldMin, worldMax, planes[i])) {
            visible = false;
            break;
        }
    }

    if ( !visible )
        return false;

    return true;
}

void setVisible( in uint gid, in uint n )
{
    // use one uint per node (max: MAX_NODES_PER_MODEL)
    //uint nodeIndex = gid * UINTS_PER_OBJECT + n;
    //atomicOr(visbuf[nodeIndex], 1u);

    // use one bit per node (max: MAX_NODES_PER_MODEL * 32)
    uint visIndex = gid * MAX_NODES_PER_MODEL + (n >> 5);
    uint bitIndex = n & 31u;
    atomicOr(visbuf[visIndex], 1u << bitIndex);
}

void main()
{	
    if (gl_LocalInvocationID.x == 0) {
        mat4 viewProj = uPMatrix * uVMatrix;
        frustumPlanes( viewProj );
    }
    barrier();

	uint gid = gl_GlobalInvocationID.x;

    GameObjectBlock obj = gameObjects[gid];

    if (gid >= numGameObjects || obj.enabled == 0) 
		return;

	ModelBlock model = models[obj.model_index];

    for (uint n = 0; n < model.nodeCount; n++)
    {
        uint meshNodeMatrixId = model.nodeOffset + n;
        
        // plane frustum culling
        if( !frustumCull(obj, meshNodeMatrixId) )
            continue;

        atomicAdd(meshInstanceCounter[meshNodeMatrixId], 1);

        // when visible set to 1u
        // else, no need to set 0u, buffer is cleared before dispatch
        setVisible( gid, n );
    }
}