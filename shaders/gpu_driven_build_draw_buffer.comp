#version 430

struct DrawBlock
{
	mat4 model;        // 64 bytes
	int  material;     // 4 bytes
	int  meshNodeMatrixId;
	int  gameObjectMatrixId;
	int  pad2;
};

struct MeshNodeBlock
{
	mat4 model;        // 64 bytes
	int  num_indices;     // 4 bytes
	int  firstIndex;
	int  baseVertex;
	int  pad2;
};

struct GameObjectBlock
{
	mat4 model;        // 64 bytes
	int  model_index;     // 4 bytes
	int  pad0;
	int  pad1;
	int  pad2;
};

struct InstancesBlock
{
	uint gameObjectId;
	uint meshNodeMatrixId;
	uint pad0;
	uint pad1;
};

layout(std430, binding = 0) buffer DrawBuffer
{
	DrawBlock draw[];
};

layout(std430, binding = 1) buffer MeshNodeBuffer
{
	//mat4 matrices[];
    MeshNodeBlock mesh_node[];
};

layout(std430, binding = 5) buffer GameObjectMatrices
{
    GameObjectBlock gameObjects[];
};

layout(binding = 9) buffer InstancesBuffer {
    InstancesBlock instances[];
};

layout( binding = 11 ) buffer InstanceCounter
{
    uint num_instances;
};

layout(local_size_x = 128) in;

void main()
{	
	uint gid = gl_GlobalInvocationID.x;

	if (gid >= num_instances) return;

	uint meshNodeMatrixId = instances[gid].meshNodeMatrixId;
	uint gameObjectMatrixId = instances[gid].gameObjectId;

	// build the draw buffer, this is used in color pass shaders
	// it holds the modelmatrix, material, and references to the gameobject and model
	draw[gid].model = gameObjects[gameObjectMatrixId].model * mesh_node[meshNodeMatrixId].model;
	draw[gid].meshNodeMatrixId = int(meshNodeMatrixId);
	draw[gid].gameObjectMatrixId = int(gameObjectMatrixId);
	draw[gid].material = 0;
}